'''
exception đầu có thể bypass bằng cách Không debug ngay từ đầu mà attach vào tiến trình sau khi nhập

Đặt bp ở .text:00221586 để vào hàm mã hóa đầu tiên (17 kí tự đầu): ^ 1

đặt bp ở .text:0022136B để thấy các kí tự sau (8 cái tiếp theo): ^ 0xab

.text:0022137E: (0xc ký tự tiếp theo) : shl 1, or 1, ^ 0xcd

step4

step5: có try catch và int2d, sau đó thấy 2 đoạn code so sánh i với 0x5 khá giống nhau, cộng thêm việc biết rõ flag phải có 5 kí tự tiếp: (006D1221) và  (006D127E) => Đi theo đúng luồng không debug thì sẽ đi trực tiếp đến except mà không đi qua lệnh dưới int2d

step6: tương tự step5, => vào exception sẽ thấy 4 ký tự tiếp đươc xor với 0xC0FE1337

'''

'''  

'''
encrypt_flag = [
  0x74, 0x6f, 0x69, 0x35, 0x4f, 0x65, 0x6d, 0x32, 0x32, 0x79, 0x42, 0x32, 0x71, 0x55, 0x68, 0x31, 0x6f, #   unh4Ndl33xC3pTi0n
  0x5f,        
  
  0xdb, 0xce, 0xc9, 0xef, 0xce, 0xc9, 0xfe, 0x92, # pebDebU9
  0x5f,          
  
  0x10, 0x27, 0xbc, 0x9, 0x0e, 0x17, 0xba, 0x4d, 0x18, 0xf, 0xbe, 0xab, # nt9lob4Lfl49    
  0x5f,
  
  0x9c, 0x8e, 0xa9, 0x89, 0x98, 0x8a, 0x9d, 0x8d, 0xd7, 0xcc, 0xdc, 0x8a, 0xa4, 0xce, 0xdf, 0x8f, 0x81, 0x89,  # s0F7w4r38r34Kp01n7
  0x5f,
  
  0x69, 0x37, 0x1d, 0x46, 0x46, # int2d
  0x5f,
  
  0x5e, 0x7d, 0x8a, 0xf3, # int3
  0x5f,
  
  0x59, 0x1, 0x57, 0x67, 0x6, 0x41, 0x78, 0x1, 0x65, 0x2d, 0x7b, 0x0e, 0x57, 0x3, 0x68, 0x5d, 0x7, 0x69, 0x23, 0x55, 0x37, 0x60, 0x14, 0x7e, 0x1d, 0x2f, 0x62, # YXV0aG9ydHVuYTk5ZnJvbWtjc2M
 
  0x5f, # =
  0x62, # =
  0x5f] # =

flag = ""

for i in range(17): # 0 -> 16
	flag+=chr(encrypt_flag[i] ^ (1))
#print(len(encrypt_flag))

flag += "_"

for i in range(18, 18 + 8): # 18 -> 25
	flag+=chr(encrypt_flag[i] ^ (0xab))


flag += "_nt9lob4Lfl49_" # step3.py

flag += "s0F7w4r38r34Kp01n7_" #Step4.py

flag += "int2d_" # step5.py

flag += "int3_" #step6.py

flag += "YXV0aG9ydHVuYTk5ZnJvbWtjc2M===" #step7.py

print(flag)

